def bfs(n, m, edges, s):
    # Create a graph
    G = Graph()
    G.add_vertices(range(n))  # Add vertices from 0 to n-1

    # Add edges to the graph
    for edge in edges:
        G.add_edge(edge[0] - 1, edge[1] - 1)  # Subtracting 1 for 0-based index

    # Initialize distance array
    distances = [-1] * n  # Distance to each node initialized to -1
    distances[s - 1] = 0  # Distance to the start node is 0

    # Initialize BFS queue
    queue = [s - 1]  # Start BFS from node s (0-based index)

    while queue:
        current_node = queue.pop(0)  # Dequeue the first element

        # Explore neighbors
        for neighbor in G.neighbors(current_node):
            if distances[neighbor] == -1:  # Not visited
                distances[neighbor] = distances[current_node] + 6  # Update distance
                queue.append(neighbor)  # Enqueue the neighbor

    # Return distances excluding the starting node (s)
    return distances[:s - 1] + distances[s:]

# Parameters
n = 5
m = 3
edges = [(1, 2), (1, 3), (3, 4)]
s = 1

# Call the bfs function
result = bfs(n, m, edges, s)
print(result)  # Output distances to nodes 2 through 5

# Visualize the graph
G = Graph()
G.add_vertices(range(n))  # Add vertices from 0 to n-1
for edge in edges:
    G.add_edge(edge[0] - 1, edge[1] - 1)

# Show the graph
G.show()
